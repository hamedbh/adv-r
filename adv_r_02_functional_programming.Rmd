---
title: "Advanced R Part 2: Functional Programming"
---

R is a language that lends itself to functional programming, hence this section. A key feature is having first-class functions, which can behave like any other data structure.

# Functionals

##Â Intro 

A **functional** takes a function as input and returns a vector.

```{r}
set.seed(1)
randomise <- function(f) {
    f(runif(1e3))
}

randomise(mean)

randomise(mean)

randomise(sum)
```

Common functionals are the `*apply()` family. Hadley outlines a hierarchy that is worth remembering:

$$
\text{functionals} > \text{for loops} > \text{while loops} > \text{repeat} 
$$

## First functional: `purrr::map()`

```{r}
library(purrr)
triple <- function(x) {
    x * 3
}
map(1:3, triple)
```

Worth making it obvious that `map()` is really just an efficient implementation of a `for` loop, as below (albeit written in C to get better performance:

```{r}
simple_map <- function(x, f, ...) {
    out <- vector("list", length(x))
    for (i in seq_along(x)) {
        out[[i]] <- f(x[[i]], ...)
    }
    
    out
}

simple_map(1:3, triple)
```

The main reason to bother with `purrr::map()` is for its type-specific versions:

```{r}
map_chr(mtcars, typeof)
```

It also allows for creating anonymous functions easily with `~`:

```{r}
map_int(mtcars, ~ length(unique(.x)))
```

What is the `~` doing?

```{r}
as_mapper(~ length(unique(.x)))
```

One cool use is for generating random data.

```{r}
x <- map(1:3, ~ runif(2))
str(x)
```

Another nice feature of `purrr` is accessing elements of a list by integer and/or character (for its names), which uses `purrr::pluck()`.

Can also pass extra arguments with `...`.

```{r}
map_dbl(list(c(1:10, NA), c(1:5, NA)), mean, na.rm = TRUE)
```

## Exercises

1

```{r}
as_mapper(1L)
as_mapper("a")
as_mapper(list(1L, "x"))
```

2

```{r}
map(1:3, ~ runif(2))
map(1:3, runif(2))
```

The second version is creating an accessor function to `pluck()` from the input vector, but because there is no value at such an index it returns `NULL`.

3a

```{r}
map_dbl(mtcars, sd, na.rm = TRUE)
```

3b

```{r}
map_dbl(iris[map_lgl(iris, is.numeric)], sd, na.rm = TRUE)
```

3c

```{r}
map_int(ggplot2::diamonds[map_lgl(ggplot2::diamonds, is.factor)], 
        ~ length(levels(.x)))
```

4

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))
hist(map_dbl(trials, "p.value"))
```

5

```{r, error=TRUE}
x <- list(
  list(1, c(3, 9)),
  list(c(3, 6), 7, c(4, 7, 6))
)

triple <- function(x) x * 3
map(x, map, .f = triple)
#> Error in .f(.x[[i]], ...): unused argument (map)
```

It fails because `triple` is passed to the outer call to map, rather than the inner. Can fix it easily by using `~`.

```{r}
map(x, ~ map(.x, triple))
```

Or by naming the function:

```{r}
map(x, function(x) {
    map(x, triple)
})
```

6

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

map(formulas, ~ lm(formula = .x, data = mtcars))
```

7

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))
bootstraps %>% 
    map(~ lm(mpg ~ disp, data = .x)) %>% 
    map(summary) %>% 
    map_dbl("r.squared")
```

## Purrr style

Gives an example of the purrr style that shows its basically about having a larger number of small steps, vs. the `*apply` functions or `for` loops.

## Map variants

The `map()` functions are designed to be [orthogonal](https://en.wikipedia.org/wiki/Orthogonality_(programming)) and well-structured. This means it's easy to lay them all out in a table:

|                       | List     | Atomic            | Same type   | Nothing   |
|-----------------------|----------|-------------------|-------------|-----------|
| One argument          | `map()`  | `map_lgl()`, ...  | `modify()`  | `walk()`  |
| Two arguments         | `map2()` | `map2_lgl()`, ... | `modify2()` | `walk2()` |
| One argument + index  | `imap()` | `imap_lgl()`, ... | `imodify()` | `iwalk()` |
| N arguments           | `pmap()` | `pmap_lgl()`, ... | ---         | `pwalk()` |

### Modify

Will always return an object of the same type as the input. For example, if working with a data frame:

```{r}
modify(mtcars, ~ .x * 2) %>% 
    head()
```

This does **not** modify in place, still have to be assigned to keep its output.

### For two inputs: `map2()`

Want to calculate a weighted mean:

```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)
```

To give two varying arguments to a function need `map2()`.

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```

### No outputs: `walk()` et al.

Use `walk()` when the function's side effects are of interest, rather than its values.

```{r}
welcome <- function(x) {
    cat("Welcome ", x, "!\n", sep = "")
}

names <- c("Hamed", "Sarah")

# map() returns a list of the values returned as well as 'doing' the function
map(names, welcome)

# walk() is what we want
walk(names, welcome)
```

`walk2()` is a useful one for saving things to disk, where you need the object to be saved and the filepath.

```{r}
temp <- tempfile()
dir.create(temp)

cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)

dir(temp)
```

### Using values and indices together

For this we use `imap()`.

```{r}
imap_chr(iris, ~ paste0("The first value of ", .y, " is ", .x[[1]]))
```

### Three or more inputs

`pmap()` is an extension of `map()` and `map2()` for any number of inputs. In this case though the inputs are provided as a single list (although its elements can be lists).

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

pmap_dbl(list(trim = trims), mean, x = x)
```

Naming the elements inside `list()` is good practice to make things clearer. The books suggests doing this with `tibble::tribble()`, building up the parameters in a data frame.

```{r}
params <- tibble::tribble(
  ~ n, ~ min, ~ max,
   1L,     0,     1,
   2L,    10,   100,
   3L,   100,  1000
)

pmap(params, runif)
```

### Exercises

1

```{r}
modify(mtcars, 1)
```

Setting `.f = 1` means 'subset the first element'. In this case it replaces every row with the value from the first.

```{r}
mtcars[1, ]
```

2 

Before

```{r}
cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)
```

After

```{r}
iwalk(cyls, ~ write.csv(.x, 
                        file.path(temp, paste0("cyl-", .y, ".csv"))))
```


3 

```{r}
trans <- list(
  disp = function(x) x * 0.0163871,
  am = function(x) factor(x, labels = c("auto", "manual"))
)

nm <- names(trans)
mtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))
```

The names of the functions match the columns to which they relate, and then the last line replaces the two elements of `mtcars` with the modified versions.

The other approach:

```{r}
vars <- c("disp", "am")
mtcars[vars] <- map(vars, ~ trans[[.x]](mtcars[[.x]]))
```

4

```{r}
tmp <- write.csv(mtcars, file.path(temp, "mtcars.csv"))
tmp
```

So it returns `NULL`. Using `map2()`:

```{r}
map2(list(mtcars), file.path(temp, "mtcars.csv"), write.csv)
```

## Reduce

From the book:

> "`reduce()` is a useful way to generalise a function that works with two inputs (a binary function) to work with any number of inputs"

This example is to find the values that occur in every element of a list of numeric vectors.

```{r}
l <- map(1:4, ~ sample(1:10, 15, replace = T))

# First by using intersect() repeatedly
l[[1]] %>% 
    intersect(l[[2]]) %>% 
    intersect(l[[3]]) %>% 
    intersect(l[[4]])

# Then using reduce
reduce(l, intersect)
```

This allows for easily checking which values appear in at least one element.

```{r}
reduce(l, union)
```

Its cousin `accumulate()` keeps the intermediate results.

```{r}
accumulate(l, intersect)
```

## Predicate functionals

Can combine predicate functions, such as `is.character()`, with functionals to apply functions selectively.

- `some()` is like `any()`, returns `TRUE` if any element meets the condition;
- `every()` more like `all()`, where all values must meet the condition, but these two differ in that they terminate early;
- `detect()` returns the value of the first match, while `detect_index()` returns its position;
- `keep()` retains matching elements, while `drop()` will drop them.

```{r}
detect_index(iris, is.factor)
detect(head(iris), is.factor)
```

There are also variants of `map()` etc. that use predicates.

```{r}
map_if(head(iris), is.numeric, ~ mean(.x, na.rm = TRUE))
```

### Exercises

1

```{r}
is.na(c(1:5, NA))
```

The reason `is.na()` isn't a predicate is because it returns a logical for _every_ element of a vector, not a single logical for the whole vector. The predicate equivalent would be:

```{r}
anyNA(c(1:5, NA))
```

2 

```{r, error=TRUE}
simple_reduce <- function(x, f) {
  out <- x[[1]]
  for (i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out
}
simple_reduce(character(0), paste)
simple_reduce("a", paste)
```

Need to change the code to handle inputs of length 1 or 0.

```{r, error=TRUE}
simple_reduce2 <- function(x, f, default) {
    if (length(x) == 1L) {
        return(x)
    } else if (length(x) == 0L) {
        return(default)
    }
    out <- x[[1]]
    for (i in seq(2, length(x))) {
        out <- f(out, x[[i]])
    }
    out
}
simple_reduce2(character(0), paste)
simple_reduce2(character(0), paste, "b")
simple_reduce2("a", paste)
```

3 

```{r}
span <- function(x, f) {
    if (!(some(x, f))) {
        return(integer())
    }
    runs <- rle(unname(map_lgl(x, f)))
    longest <- max(runs$lengths[runs$values])
    longest_index <- detect_index(runs$lengths, ~ .x == longest)
    return(sum(runs$lengths[seq_len(longest_index)]) - longest + 1)
}

span(ggplot2::diamonds, is.numeric)
span(iris, is.factor)
span(iris, is.character)
```

4

```{r}
arg_max <- function(x, f, na.rm = TRUE) {
    results <- f(x)
    return(x[results == max(results, na.rm = na.rm)])
}
arg_max(-10:5, function(x) x ^ 2)
arg_max(-5:5, function(x) x ^ 2)
```

```{r}
arg_min <- function(x, f, na.rm = TRUE) {
    results <- f(x)
    return(x[results == min(results, na.rm = na.rm)])
}
arg_min(-10:5, function(x) x ^ 2)
arg_min(-5:5, function(x) x ^ 2)
```

5

```{r}
scale01 <- function(x) {
    rng <- range(x, na.rm = TRUE)
    (x - rng[1]) / (rng[2] - rng[1])
}

# apply to every column of a data frame
modify(ggplot2::diamonds, scale01)

# apply to numeric cols only
modify_if(ggplot2::diamonds, is.numeric, scale01)
```

