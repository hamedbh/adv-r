---
title: "Advanced R Part 1: Foundations"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Working through [Advanced R][1] by Hadley Wickham. Can check solutions via Peter Hurford's [GitHub repo][2] if needed.

# Data Structures

Quick quiz to see whether you need to read the chapter:

1. What are the three properties of a vector, other than its contents?  
_Its type, length, and attributes._
2. What are the four common types of atomic vectors? What are the two rare types?  
_Character, Logical, Integer, Double (Numeric); Complex, Raw_
3. What are attributes? How do you get them and set them?  
_They are the characteristics of the vector. Can get and set them with the `attr()` function._
4. How is a list different from an atomic vector? How is a matrix different from a data frame?  
_Lists can contain elements of different types, an atomic vector cannot. Matrices can only contain numeric (integer or double) values, whereas data frames can mix type._
5. Can you have a list that is a matrix? Can a data frame have a column that is a matrix?  
_Not exactly, but there's a sort of fudge called a "list-array". Yes, by assigning it._

## Vectors

- The basic data structure in R.
- Two main types: atomic vectors and lists.
- Three common properties:
1. Type, check with `typeof()`;
2. Length, `length()`;
3. Attributes, `attributes()`.

NB. `is.vector()` not appropriate for testing whether an object is a vector, as it only returns `TRUE` if the object is a vector with no attributes other than names.

```{r}
x <- 1:2
is.vector(x) # returns TRUE
names(x) <- c("a", "b")
is.vector(x) # still returns TRUE
attr(x, "extra") <- c("a", "b")
is.vector(x) # now will return FALSE
is.atomic(x) # Use this instead to test if object is an atomic vector
# And to test whether it's a vector at all .
is.atomic(x) || is.list(x)
# try it with a list()
y <- list(1, 2, 3)
is.atomic(y) || is.list(y)
```

### Atomic Vectors

- Create with `c()` (short for combine).
- Always flat, even with nested calls to `c()`, so `c(1, c(2, 3, c(4, 5)))` will return `1, 2, 3, 4, 5`.
- Four common types: Character, Logical, Integer, Double (Numeric).

#### Types and Tests

Can check type of an object with `typeof()` and check specific types with `is.character()`, `is.integer()` etc.

NB. `is.numeric()` more generic, returns `TRUE` for both integer and double types.

#### Coercion

When combining elements of different types in a single vector they will be **coerced** to the most flexible type. From least to most flexible:

- Logical;
- Integer;
- Double;
- Character.

```{r}
str(c("a", 1))
str(c(TRUE, 1L))
str(c(TRUE, 1L, 1))
# Logicals are coerced to 1, 0 for TRUE, FALSE, which allows for easy
# calculations
x <- c(TRUE, FALSE, TRUE, TRUE)
# How many returned TRUE?
sum(x)
# Proportion returned TRUE?
mean(x)
```

### Lists

Construct with `list()`.

```{r}
x <- list(list(1, 2), c(3, 4))
str(x)
# Contrast with c(), which will turn all arguments to their own lists if given 
# a list as an argument
y <- c(c(1, 2), list(3, 4))
str(y)
```

Many other data structures, such as data frames and model outputs, are lists.

```{r}
is.list(mtcars)
is.list(lm(mpg ~ wt, data = mtcars))
```

### Exercises

1. What are the six types of atomic vector? How does a list differ from an atomic vector?  
_The six types are Character, Double, Integer, Logical, Complex, and Raw. A list differs because it can contain elements of different types (including other lists)._
2. What makes `is.vector()` and `is.numeric()` fundamentally different to `is.list()` and `is.character()`?  
_The first two functions will each return_ `TRUE` _for more than one type, whereas the latter two will only return_ `TRUE` _for one type each._
3. Test your knowledge of vector coercion rules by predicting the output of the following uses of c():  
`c(1, FALSE)` returns `integer: 1 0`
`c("a", 1)` returns `character "a" "1"`
`c(list(1), "a")` returns a list, first element `"1"`, then `"a"`
`c(TRUE, 1L)` returns `integer: 1 1`

```{r}
str(c(1, FALSE))
str(c("a", 1))
str(c(list(1), "a"))
str(c(TRUE, 1L))
```

4. Why do you need to use `unlist()` to convert a list to an atomic vector? Why doesn't `as.vector()` work?  
_Because a list is a vector, just not an atomic one._
5. Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?  
_All relate to coercion of different data types. In the first case the integer `1` is coerced to `"1"`; in the second `FALSE` is coerced to `0`; in the last `2` is coerced to `"2"`, and numbers are before letters in alphabetical order._
6. Why is the default missing value, `NA`, a logical vector? What's special about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)  
_Logical is the least 'flexible' atomic vector type: by making this the default, any time `NA` is included in another vector type it can be coerced to a more flexible type, rather than forcing the non-`NA` elements to be coerced._

## Attributes

A way to store arbitrary metadata for any object. Access individually with `attr()` or see all with `attributes()`.

```{r}
y <- 1:10
attr(y, "my_attribute") <- "This is a vector"
attr(y, "my_attribute")
str(attributes(y))
```

Most attributes lost when modifying a vector.

```{r}
attributes(y)
attributes(y[1])
attributes(sum(y))
```

The most important attributes are preserved:

- Names;
- Dimensions;
- Class.

Access these with `names()`, `dim()`, `class()` respectively. (Easier and safer than using `attr(x, "names")` etc.)

### Names

Names vectors in any of three ways:

```{r}
# Method 1: when creating
x <- c(a = 1, b = 2, c = 3)

# Method 2: modify in place
y <- c(1, 2, 3)
names(y) <- c("a", "b", "c")

# Method 3: create modified copy of another vector
z <- setNames(1:3, c("a", "b", "c"))

# Do they all give the same result?
all.equal(x, y)
all.equal(x, z)
```

Names don't have to be unique, but it's a good idea anyway: helps with subsetting by character.

### Factors

Attributes make factors work: underneath a factor is an integer vector, but with `class` and `levels` attributes.

```{r}
x <- factor(c("a", "b", "b", "b"))
x
typeof(x)
class(x)
levels(x)
attributes(x)
# Can't use a value that's not in the levels
x[2] <- "c"
x
```

Useful for many things including when we know all possible values the variable may take.

```{r}
# create character vector of sex in a unisex group
sex_char <- rep("f", 3)
# create a factor with all possible values
sex_fct <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
table(sex_fct)
```

Factors can crop up when reading from a file: columns that 'should' be numeric are instead factors, caused by non-numeric characters used to represent missing data. The fast and dirty method to handle this is to:

1. Coerce with `as.character()`;
2. Coerce with `as.double()`;
3. Check for missing values.

More thorough method is to figure out which string is being used to represent missing values and set the `na.strings` argument to `read.csv()` accordingly. (Or avoid this altogether by using the `readr::read_*()` functions.)

```{r}
z <- read.csv(text = "value\n12\n1\n.\n9")
typeof(z$value)
as.double(z$value)
class(z$value)

# Dirty method
as.double(as.character(z$value))

# Thorough method
z <- read.csv(text = "value\n12\n1\n.\n9", 
              na.strings = ".")
z$value
class(z$value)
```

Also a good idea to set `stringsAsFactors = FALSE` if using the `read.*()` functions from `utils`.

### Exercises

1. An early draft used this code to illustrate `structure()`:

`structure(1:5, comment = "my attribute")`

But when you print that object you don't see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)

```{r}
# Help file for comment() has the answer:
# "Contrary to other attributes, the comment is not printed (by print or 
# print.default)."

# Can demonstrate by adding another attribute

structure(1:5, 
          comment = "my attribute", 
          other_attr = "show this attribute")
```

2. What happens to a factor when you modify its levels?

```{r}
f1 <- factor(letters)
f1
levels(f1) <- rev(levels(f1))
f1
# Both the values and the levels are reversed
```

3. What does this code do? How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))
f2
f3 <- factor(letters, levels = rev(letters))
f3
```

For `f2` only the values are reversed; for `f3` only the levels are reversed.

## Matrices and Arrays

By adding a `dim` attribute to a vector it will behave like a multidimensional **array**. **Matrices** are arrays with two dimensions, and are a common part of many statistical processes.

```{r}
# matrix() and array() are functions to create these structures
A <- matrix(1:6, 
            ncol = 3, 
            nrow = 2 # bit redundant to set this as it will infer nrow from the 
            # x and ncol arguments
)
A
B <- array(1:12, 
           # one vector argument to specify all dimensions
           c(2, 3, 2))
B

# R uses column-major by default, can change by setting argument `byrow = TRUE`

# Can create a matrix or array from a vector by setting dim
vec <- 1:6
dim(vec) <- c(2, 3)
vec
all.equal(A, vec)
```

When moving from vectors to matrices, and then arrays:

- `length()` becomes `nrow()` and `ncol()`, then `dim()`.
- `names()` becomes `colnames()` and `rownames()`, then `dimnames()`.

```{r}
length(A)
nrow(A)
ncol(A)
rownames(A) <- c("a", "b")
A
colnames(A) <- c("a", "b", "c")
A
length(B)
dim(B)
dimnames(B) <- list( # given as a list
    c("one", "two"), 
    c("a", "b", "c"), 
    c("A", "B")
)
B
```

### Exercises

1. What does `dim()` return when applied to a vector?

```{r}
dim(1:10)
```

2. If `is.matrix(x)` is `TRUE`, what will `is.array(x)` return?

```{r}
is.matrix(A)
is.array(A)
```

3. How would you describe the following three objects? What makes them different to `1:5`?

`x1 <- array(1:5, c(1, 1, 5))`  
`x2 <- array(1:5, c(1, 5, 1))`  
`x3 <- array(1:5, c(5, 1, 1))`  

All three contain the same elements, but they each have different dimensions. 

## Data frames

Underneath a data frame is a list, but with constraints (e.g. all elements must be vectors of the same length).

Can subset it like a list (1D) or a matrix (2D).

### Creation

Create by passing named vectors to `data.frame()`.

```{r}
df <- data.frame(
    x = 1:3, 
    y = c("a", "b", "c")
)
str(df)

# preserve the strings as strings
df <- data.frame(
    x = 1:3, 
    y = c("a", "b", "c"), 
    stringsAsFactors = FALSE
)
str(df)
```

### Testing and coercion

```{r}
# data.frame is an S3 class so its type is that of the underlying object
typeof(df)
# need to check its class or use the built-in predicate function
class(df)
is.data.frame(df)
```

Coercion to `data.frame` will work differently depending on the input, but can accept a single vector, a list (as long as all elements are the same length), or a matrix.

### Combining data frames

Use `cbind()` and `rbind()` to combine data frames. If the arguments are vectors though `cbind()` will create a matrix. 

```{r}
cbind(df, 
      data.frame(z = 3:1))
rbind(df, data.frame(x = 10, y = "z"))
```

### Special columns

Can put lists in as columns of a data frame but need to use `I()` to prevent `data.frame()` from trying to create a separate column for each element of the list.

```{r, error=TRUE}
data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
dfl <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(dfl)
```

### Exercises

#### Q1

What attributes does a data frame possess?

```{r}
attributes(df)
```

#### Q2

What does `as.matrix()` do when applied to a data frame with columns of different types?

```{r}
as.matrix(df)
```

It coerces all columns to the most flexible type present.

#### Q3

Can you have a data frame with 0 rows? What about 0 columns?

```{r}
data.frame()
```

Yes.

# Subsetting

There are:

- 3 subsetting operators;
- 6 types of subsetting;
- Different behaviour when subsetting different objects;
- Considerations when using subsetting with assignment.

## Quiz

1. What is the result of subsetting a vector with positive integers, negative integers, a logical vector, or a character vector?  
_Subsetting with positive integers will include the elements at those positions in the vector. With negative integers will exclude those elements. A logical vector will include `TRUE` elements and exclude `FALSE` ones. A character vector will extract those elements whose names match the elements of the character vector._
2. What’s the difference between `[`, `[[`, and `$` when applied to a list?  
_The `[` will return a list type object. The `[[` will return an object of the same type as the corresponding element of the list. The `$` behaves much as the `[[` does._
3. When should you use `drop = FALSE`?  
_This argument will prevent the output from being 'dropped` to a simpler type. For example when subsetting a an integer column of a data frame it will prevent the output from being simplified to an integer vector and return a data frame instead._
4. If x is a matrix, what does x[] <- 0 do? How is it different to x <- 0?  
_It will change every element of the matrix to zero, whereas `x <- 0` will assign the numeric value zero to the name `x`._
5. How can you use a named vector to relabel categorical variables?  
_ Can use the named vector as a lookup._

## Selecting multiple elements

### Atomic vectors

Simplest example is of subsetting a vector. Six things to use for subsetting.

1. Positive integers 

```{r, error=TRUE}
# Create the vector. The decimal part of each is its position in the vector.
x <- c(2.1, 4.2, 3.3, 5.4)
## 
x[c(3, 1)]
x[order(x)]
# can duplicate indices, will duplicate the values
x[c(1, 1)]
# using a non-integer real number will use the integer part for indexing
x[c(2.1, 2.9)]
```

2. Negative integers

```{r, error=TRUE}
x[-c(3, 1)]
# can't mix positive and negative integers
x[c(-1, 2)]
```

3. Logical vectors

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]
x[x > 3]
# shorter logical vector will be recycled
x[c(TRUE, FALSE)]
# show that this is equivalent
all.equal(x[c(TRUE, FALSE)], x[c(TRUE, FALSE, TRUE, FALSE)])
```

4. Nothing

```{r}
# returns the original vector
x[]
```

This is more useful with two-dimensional (or greater) objects. 

5. Zero

```{r}
x[0]
```

This will always return a zero-length vector.

6. Names

Can only use for named vectors.

```{r}
(y <- setNames(x, letters[seq_along(x)]))
y[c("d", "c", "a")]
# using these with an unnamed vector will return NAs
x[c("d", "c", "a")]
```

### Lists

These work the same as vectors in the main. One extra consideration is that `[` will always return a list, whereas `[[` and `$` will extract the components of the list.

### Matrices and arrays

Three ways to do this:

1. Multiple vectors; 
2. Single vector; 
3. Matrix.

Can simply generalise from subsetting vectors.

```{r}
A <- matrix(1:9, nrow = 3)
colnames(A) <- c("a", "b", "c")
A[1:2, ]
A[c(TRUE, FALSE, TRUE), c("b", "a")]
A[0, -2]
```

Using `[` will simplify the result as much as possible.

```{r}
A[1, ] # drops to a 1D vector
A[1, 1] # also drops to 1D vector
```

Because matrices and arrays are just stored a vectors plus the dimensions can subset them as though they were just vectors.

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals

vals[c(4, 15)]
```

This extends to using an integer matrix to subset a higher-dimensional array. Each row specifies the location of a value, and each column is a dimension in the array.

```{r}
select <- matrix(ncol = 2, 
                 byrow = TRUE, 
                 c(1, 1, 
                   3, 1, 
                   2, 4))
vals[select]
```

### Data frames

Can behave like lists or matrices:

- If using a single index behaves like a list, selecting the relevant columns of the data frame.
- If using two indices it behaves like a matrix.

```{r}
df <- data.frame(x = 1:3, 
                 y = 3:1, 
                 z = letters[1:3])

df[df$x == 2, ]

df[c(1, 3), ]

# can select columns like a list
df[c("x", "z")]

# or like a matrix
df[, c("x", "z")]

# note that when subsetting matrix-style result will be simplified, but not when 
# subsetting list-style
str(df["x"])
str(df[, "x"])
```

Tibbles behave differently: using `[` will always return another tibble.

```{r}
df <- tibble::tibble(x = 1:3, 
                     y = 3:1, 
                     z = letters[1:3])

df["x"]
df[, "x"]
```

### Preserving dimensionality

By default when using a single name, number, or value of TRUE, the result will be simplified. Can prevent this with `drop = FALSE`.

```{r}
A <- matrix(1:4, nrow = 2)
str(A[1, ])

str(A[1, , drop = FALSE])

df <- data.frame(a = 1:2, b = 1:2)
str(df[, "a"])

str(df[, "a", drop = FALSE])
```


When programming should specify `drop = FALSE` to prevent errors caused by simplification when subsetting with a single index. Another reason to prefer tibbles, where that is the default.

### Exercises

1. Fix each of the following common data frame subsetting errors:

```{r}
# mtcars[mtcars$cyl = 4, ]
# must use == for comparison
mtcars[mtcars$cyl == 4, ]

# mtcars[-1:4, ]
# attempting to create a sequence from -1 to 4, mixing positive and negative 
# numbers, which won't work.
mtcars[-(1:4), ]

# mtcars[mtcars$cyl <= 5]
# need the trailing comma to specify that all columns are to be returned
mtcars[mtcars$cyl <= 5, ]

# mtcars[mtcars$cyl == 4 | 6, ]
# the second condition must be specified in full, or the equality can be 
# replaced with %in%
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
mtcars[mtcars$cyl %in% c(4, 6), ]
```

2. Why does the following code yield five missing values? (Hint: why is it different from `x[NA_real_]`?)

```{r}
x <- 1:5
x[NA]
x[NA_real_]
```

This is because the vector is type integer, so in the call `x[NA]` the `NA` is coerced to logical, and then it returns `NA` at each index because its value is neither `TRUE` nor `FALSE`. Whereas subsetting with a real number does not make sense, so the result is just `NA`. Compare this to the different types of `NA`.

```{r, error=TRUE}
x[NA_character_]
x[NA_complex_]
x[NA_integer_]
```

3. What does `upper.tri()` return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x[upper.tri(x)]
```

`upper.tri(x)` returns a logical matrix with the same dimensions as `x` where only the upper-trinagular entries are `TRUE` (not including the diagonal). Because it's subsetting with `[]` the result is simplified to a vector.

4. Why does `mtcars[1:20]` return an error? How does it differ from the similar `mtcars[1:20, ]`?

```{r, error=TRUE}
mtcars[1:20]
```

We can see that `mtcars` has `r ncol(mtcars)` variables, so we are trying to access columns that don't exist. Adding a comma inside the `[]` changes the request to 'return the first 20 rows of `mtcars`'.

```{r}
mtcars[1:20, ]
```

Implement your own function that extracts the diagonal entries from a matrix (it should behave like `diag(x)` where `x` is a matrix).

```{r}
get_diag <- function(X) {
    if (!nrow(X) == ncol(X)) {
        stop("get_diag is for square matrices only")
    }
    indices <- seq_len(nrow(X))
    return(X[matrix(c(indices, 
                      indices), 
                    ncol = 2, 
                    byrow = FALSE)])
}

get_diag(A)
get_diag(x)
```

6. What does `df[is.na(df)] <- 0` do? How does it work?

Can start by looking at the inside statement on a data frame with some missing values.

```{r}
d <- data.frame(x = 1:5, 
                y = c(6, NA, 8, 9, NA), 
                z = c("a", "b", NA, NA, NA), 
                stringsAsFactors = FALSE)
is.na(d)
```

So this returns a logical matrix of the same dimensions as the data frame, which is TRUE for entries that are `NA`. Subsetting using that returns a vector.

```{r}
d[is.na(d)]
```

But then using that on the left side of the assignment replaces the relevant values with `0`.

```{r}
d[is.na(d)] <- 0

d
```

## Selecting a single element

This is where the `[[` and `$` operators become useful.

### `[[`

Can use the train metaphor:

> If `x` is a list then x[[5]] is the object in car number 5, whereas x[5] is a 
> smaller train consisting of just car number 5.

```{r}
x <- list(1:3, "a", 4:6)
```

When extracting a single element we have the option of either getting that car or making a smaller train with just that car, which is double brackets and single brackets respectively.

```{r}
x[[1]]
x[1]
```

But if we want either multiple or zero elements we need to make a smaller train.

```{r}
x[1:2]
x[-2]
x[c(1, 1)]
x[0]
```

Trying to use multiple values with `[[` will either subset recursively at deeper levels of the list (if possible), or throw an error.

```{r, error=TRUE}
x[[c(1, 2)]] # returns second element of the first element

x[[c(1, 7)]] # throws an error because first element has no seventh element
```

`[[` can also be used with vectors, as shown implicitly in that last code block. And doing so makes it explicit that we are accessing a single element.

### `$`

This is mostly just a shorthand for accessing elements by name: `x$y` is about the same as `x[["y]]`. It won't work when the name is stored in a variable.

```{r, error=TRUE}
variable <- "cyl"

# this won't work, it's basically mtcars[["variable"]]
mtcars$variable

# but this does work
mtcars[[variable]]
```

`$` will do partial matching, which can be dangerous!

```{r}
# set this option to FALSE as I set it to TRUE in my .Rprofile after 
# reading this section!
options(warnPartialMatchDollar = FALSE)

x <- list(abc = 1)
x$a
x[["a"]]
```

Can prevent this through options.

```{r}
options(warnPartialMatchDollar = TRUE)
x$a
```

### Missing or out-of-bounds indices

The results for using these invalid indices can vary a lot, as per the table below.

| `row[[col]]` | Zero-length | OOB (int)  | OOB (chr) | Missing  |
|--------------|-------------|------------|-----------|----------|
| Atomic       | Error       | Error      | Error     | Error    |
| List         | Error       | Error      | `NULL`    | `NULL`   |
| `NULL`       | `NULL`      | `NULL`     | `NULL`    | `NULL`   |

All of this gives rise to the usefulness of `purrr::pluck()` (which will always return `NULL` when the element is missing) and `purrr::chuck()` (which throws an error).

```{r}
x <- list(
    a = list(1, 2, 3), 
    b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)

purrr::pluck(x, "c", 1)

purrr::pluck(x, "c", 1, .default = NA)
```

### `@` and `slot()`

Need these for S4 objects (such as certain sparse matrices). More details later.

### Exercises

1. Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.

```{r}
mtcars[3, 2]
mtcars[3, "cyl"]
mtcars[[2]][[3]]
mtcars[[2]][3]
mtcars[["cyl"]][[3]]
mtcars[["cyl"]][3]
mtcars[2][3, ]
```

2. Given a linear model, e.g., `mod <- lm(mpg ~ wt, data = mtcars)`, extract the residual degrees of freedom. Then extract the R squared from the model summary `(summary(mod))`.

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
mod[["df.residual"]]
summary(mod)[["r.squared"]]
```

## Subsetting and assignment

As seen earlier with the `d[is.na(d)] <- 0` example subsetting can be used on the left of assignment to change those elements, which is called **subassignment**.

```{r}
x <- 1:5

x[c(1, 2)] <- c(101, 102)
x
```

Using `NULL` on the right of the `<-` with a list will remove that element. To instead replace that element with `NULL` use `list(NULL)`.

```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)

y <- list(a = 1, b = 2)
y[["b"]] <- list(NULL)
str(y)
```

In this context subsetting with nothing can be useful, as below.

```{r}
d <- mtcars

d[] <- lapply(d, as.integer)
is.data.frame(d)

d <- lapply(d, as.integer)
is.data.frame(d)
```

In the first one it is the elements of `d` that get changed: in the second the output from `lapply(d, as.integer)` (which is a list, not a data frame) is assigned to the name `d`.

## Applications

Some examples of how to use the subsetting techniques above.

### Lookup tables

To convert abbreviations:

```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]

# can also drop the names if preferred
unname(lookup[x])
```

### Matching and merging by hand

```{r}
# vector of grades
grades <- c(1L, 2L, 2L, 3L, 1L)

# lookup table with details for each grade
info <- data.frame(
    grade = 3:1, 
    desc = c("Excellent", 
             "Good", 
             "Poor"), 
    fail = c(FALSE, FALSE, TRUE)
)

# subset the lookup table repeatedly based on which grade matches
info[match(grades, info$grade), ]
```

If the join conditions were more complex then switching to `dplyr::left_join()` or `merge()` would be better.

### Random samples and bootstraps

```{r}
df <- data.frame(
    x = c(1, 2, 3, 1, 2), 
    y = 5:1, 
    z = letters[1:5]
)

# randomly reorder
df[sample(nrow(df)), ]

# sample three rows
df[sample(nrow(df), size = 3), ]

# take a bootstrap sample
df[sample(nrow(df), replace = TRUE), ]
```

### Ordering

```{r}
x <- c("b", "c", "a")
order(x)

x[order(x)]
```

Can use this in 2 or more dimensions also.

```{r}
df2 <- df[sample(nrow(df)), 3:1]
df2

df2[order(df2$x), ]

df2[, order(names(df2))]
```

Can also use `sort()` to directly sort a vector, and `dplyr::arrange()` to sort a data frame.


### Expanding aggregated counts

Take advantage of `rep()` being vectorised: `rep(x, y)` repeats `x[i]` `y[i]` times.

```{r}
df <- data.frame(x = c(2, 4, 1), 
                 y = c(9, 11, 6), 
                 n = c(3, 5, 1))

rep(seq_len(nrow(df)), df$n)

df[rep(seq_len(nrow(df)), df$n), ]
```

### Removing columns from data frames

Can set individual columns to `NULL`. 

```{r}
df <- data.frame(x = 1:3, 
                 y = 3:1, 
                 z = letters[1:3])

df$z <- NULL

df
```

Or specify just the columns needed. 

```{r}
df <- data.frame(x = 1:3, 
                 y = 3:1, 
                 z = letters[1:3])

df[c("x", "y")]
```

Or specify columns to drop using `setdiff()`.

```{r}
df[setdiff(names(df), "z")]
```

### Selecting rows based on a condition

```{r}
mtcars[mtcars$gear == 5, ]

mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```

Must use `&` and `|` instead of `&&` and `||`.

### Boolean algebra vs. sets

There's a natural equivalence between set operations (integer subsetting) and Boolean algebra (logical subsetting). In general set operations will be better when:

- You want to find the first or last `TRUE`.
- There are very few `TRUE`s.

`which()` allows for switching from Boolean to integer. There's no built-in reverse but we can create one.

```{r}
x <- sample(10) < 4
which(x)

unwhich <- function(x, n) {
    out <- rep_len(FALSE, n)
    out[x] <- TRUE
    out
}

unwhich(which(x), 10)
```

Now create two logical vectors and their integer equivalents, examine the relationship between set and Boolean operations.

```{r}
(x1 <- 1:10 %% 2 == 0)

(x2 <- which(x1))

(y1 <- 1:10 %% 5 == 0)

(y2 <- which(y1))

# x & y <-> x intersect y
x1 & y1
intersect(x2, y2)

# x | y <-> x union y
x1 | y1
union(x2, y2)

# x & !y <-> setdiff(x, y)
x1 & !y1
setdiff(x2, y2)

# xor(x, y) <-> setdiff(union(x, y), intersect(x, y))
xor(x1, y1)
setdiff(union(x2, y2), intersect(x2, y2))
```

### Exercises

1. How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?

```{r}
set.seed(1)
mtcars[sample(nrow(mtcars)), sample(ncol(mtcars))]
```

2. How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?

```{r}
# first take just m rows from anywhere
sample_size <- 7
# set.seed(1)
mtcars[sample(nrow(mtcars), sample_size), ]

# now ensure that the sample is contiguous
mtcars[seq(from = sample(nrow(mtcars) - sample_size + 1, size = 1), 
           by = 1, 
           length.out = sample_size), ]
```

3. How could you put the columns in a data frame in alphabetical order?

```{r}
mtcars[, order(names(mtcars))]
```

# Control Flow

## Intro

Two main tools:

- Choices, such as calls to `switch()` or `if` statements.
- Loops, which as `for` and `while`.

### Quiz

- What is the difference between `if` and `ifelse()`?  
_`if` will run the subsequent code when the condition is `TRUE` but otherwise does nothing. `ifelse()` will return a value either way, as specified in its arguments._
- In the code `y <- if(x) 3` what will the value of `y` be when`x` is `TRUE`, `FALSE`, or `NA`?  
_These will be `3`, `NULL`, and an error respectively._
- What does `switch("x", x = , y = 2, z = 3)` return?  
_It will return 2: this is the drop syntax borrowed from C._

## Choices

Basic form for an `if` statement is:

if (condition) true_action
if (condition) true_action else false_action

More commonly the actions will be compound statements, so they must be wrapped in `{}`.

```{r}
grade <- function(x) {
    
    if (x > 90) {
        "A"
    } else if (x > 80) {
        "B"
    } else if (x > 50) {
        "C"
    } else {
        "F"
    }
}
```

`if` returns a value so can use it for assignment.

```{r}
x1 <- if (TRUE) 1 else 2
x2 <- if (FALSE) 1 else 2

c(x1, x2)
```

Without an `else` statement, and when the condition is `FALSE`, `if` will return `NULL` invisibly. This can be used with the fact that functions like `c()` and `paste()` drop `NULL` inputs.

```{r}
greet <- function(name, birthday = FALSE) {
    paste0(
        "Hi ", name, 
        if (birthday) " and HAPPY BIRTHDAY"
    )
}

greet("Maria", FALSE)
greet("James", TRUE)
```


### Invalid inputs

If the condition doesn't evaluate to a single `TRUE` or `FALSE` then this will usually throw an error.

```{r, error=TRUE}
if ("x") 1

if (logical()) 1

if (NA) 1
```

Or in some cases a warning.

```{r}
# have to set this variable to false as I've updated my Rprofile
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "false")
if (c(TRUE, FALSE)) 1
```

Can change this behaviour with an environment variable.

```{r, error=TRUE}
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")
if (c(TRUE, FALSE)) 1
```

### Vectorised if

Use `ifelse()` to handle a vector of logical values.

```{r}
x <- 1:10

ifelse(x %% 5 == 0, "XXX", as.character(x))

ifelse(x %% 2 == 0, "even", "odd")
```

Good practice to ensure that both the `yes` and `no` vectors are the same type, or the outputs will be unstable.

Can also use `dplyr::case_when()`.

```{r}
dplyr::case_when(
    x %% 35 == 0 ~ "fizz buzz", 
    x %% 5 == 0  ~ "fizz", 
    x %% 7 == 0  ~ "buzz", 
    is.na(x)     ~ "???", 
    TRUE         ~ as.character(x)
)
```

### `switch()`

Allows for representing code more compactly.

This:

```{r}
x_option <- function(x) {
    if (x == "a") {
        "option 1"
    } else if (x == "b") {
        "option 2" 
    } else if (x == "c") {
        "option 3"
    } else {
        stop("Invalid `x` value")
    }
}
```

Can become this:

```{r}
x_option <- function(x) {
    switch(x, 
           a = "option 1", 
           b = "option 2", 
           c = "option 3", 
           stop("Invalid `x` value")
    )
}
```

And you can use the drop syntax when multiple inputs have the same output.

```{r}
legs <- function(x) {
    switch(x, 
           cow = , 
           horse = , 
           dog = 4, 
           human = , 
           chicken = 2, 
           plant = 0, 
           stop("Unknown input")
    )
}

legs("cow")
legs("dog")
```

`switch()` works best with character inputs, so stick to using it there. 

### Exercises



[1]: http://adv-r.had.co.nz/
[2]: https://github.com/peterhurford/adv-r-book-solutions